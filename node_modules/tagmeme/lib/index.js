'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var invariant = require('invariant');
var hasOwnProperty = Object.prototype.hasOwnProperty;

function checkTypes(types) {
  invariant(Array.isArray(types), 'types must be an array');

  var seen = Object.create(null);
  for (var i = 0; i < types.length; i++) {
    var type = types[i];
    invariant(typeof type === 'string', 'Tag type must be a string');
    invariant(!seen[type], 'Duplicate tag type "' + type + '". Types must be unique');
    seen[type] = true;
  }
}

function checkMatch(handlers, catchAll, types) {
  var seenTypes = [];
  for (var key in handlers) {
    invariant(types.includes(key), 'Key "' + key + '" is not a tag type of the union');
    var handler = handlers[key];
    invariant(typeof handler === 'function', 'Key "' + key + '" value must be a function');
    seenTypes.push(key);
  }

  if (catchAll) {
    invariant(types.length !== seenTypes.length, 'All types are handled; remove unnecessary catch-all');
    invariant(typeof catchAll === 'function', 'catch-all must be a function');
  } else {
    var missingTypes = types.filter(function (type) {
      return !seenTypes.includes(type);
    });
    invariant(types.length === seenTypes.length, 'All types are not handled; add a catch-all. Missing types: ' + missingTypes.join(', '));
  }
}

function checkTag(tag, tagType, types) {
  invariant((typeof tag === 'undefined' ? 'undefined' : _typeof(tag)) === 'object', 'Tag must be an object');
  invariant(typeof tag.type === 'string', 'Tag type must be a string');
  invariant(typeof tagType === 'string', 'Tag type must be prefixed');
  invariant(types.includes(tagType), 'Tag must be a tag of the union');
}

function checkType(type, tagUnion) {
  invariant(type, 'Type must be provided');

  for (var key in tagUnion) {
    if (tagUnion[key] === type) {
      return;
    }
  }

  invariant(false, 'Type must be a type of the union');
}

function safeUnion(types, options) {
  if (process.env.NODE_ENV !== 'production') {
    checkTypes(types);
  }

  var prefix = options && options.prefix || '';
  var prefixSize = prefix.length;
  var stripPrefix = prefixSize ? function (tag) {
    return tag && tag.type && tag.type.startsWith(prefix) && tag.type.slice(prefixSize);
  } : function (x) {
    return x && x.type;
  };

  var matcher = function matcher(handlers, catchAll) {
    if (process.env.NODE_ENV !== 'production') {
      checkMatch(handlers, catchAll, types);
    }

    return function _matcher(tag, context) {
      var tagType = stripPrefix(tag);
      if (process.env.NODE_ENV !== 'production') {
        checkTag(tag, tagType, types);
      }

      var match = hasOwnProperty.call(handlers, tagType) && handlers[tagType];
      return match ? match(tag.data, context) : catchAll(context);
    };
  };

  var methods = {
    match: function match(tag, handlers, catchAll) {
      return matcher(handlers, catchAll)(tag);
    },

    matcher: matcher,
    matches: function matches(tag, type) {
      var tagType = stripPrefix(tag);
      if (process.env.NODE_ENV !== 'production') {
        checkTag(tag, tagType, types);
        checkType(type, variants);
      }

      return !!(typeof tagType === 'string' && variants[tagType] === type);
    }
  };

  var variants = Object.create(null);

  var _loop = function _loop(i) {
    var type = types[i];
    var prefixedType = prefix + type;
    variants[type] = function (data) {
      return { type: prefixedType, data: data };
    };
  };

  for (var i = 0; i < types.length; i++) {
    _loop(i);
  }

  return { variants: variants, methods: methods };
}

function union(types, options) {
  var _safeUnion = safeUnion(types, options),
      variants = _safeUnion.variants,
      methods = _safeUnion.methods;

  for (var key in methods) {
    if (process.env.NODE_ENV !== 'production') {
      invariant(!hasOwnProperty.call(variants, key), 'Tag type cannot be "' + key + '"');
    }
    variants[key] = methods[key];
  }
  return variants;
}

exports.union = union;
exports.safeUnion = safeUnion;